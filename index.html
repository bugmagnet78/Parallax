<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>WebXR Measurement - Visualize & Calculate</title>
    <style>
      /* CSS styles (unchanged) */
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: #000;
        color: white;
      }
      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display: block;
        color: white;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        font-size: 16px;
        box-sizing: border-box;
        min-height: 4em;
      } /* Added min-height */
      .button-container {
        position: absolute;
        bottom: 30px;
        width: 100%;
        text-align: center;
        z-index: 101;
        display: flex;
        justify-content: center;
        gap: 20px;
      }
      .button-container button {
        padding: 14px 28px;
        font-size: 18px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        transition: background-color 0.3s ease;
      }
      .button-container button:disabled {
        background-color: #555;
        color: #aaa;
        cursor: not-allowed;
        box-shadow: none;
      }
      .button-container button:hover:not(:disabled) {
        background-color: #0056b3;
      }
      #reset-button {
        background-color: #dc3545;
      }
      #reset-button:hover:not(:disabled) {
        background-color: #c82333;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="info">Initializing...</div>
    <div class="button-container">
      <button id="start-ar-button" disabled>Start Measurement</button>
      <button id="reset-button" style="display: none">Reset</button>
    </div>
    <canvas id="webgl-canvas"></canvas>

    <script type="module">
      console.log(
        '--- JavaScript module execution started (Visualize & Calculate) ---'
      );

      import * as THREE from 'three';

      console.log(
        'Three.js module imported successfully:',
        THREE ? 'Yes' : 'No'
      );

      // --- Relevant Context ---
      // Current time: Sunday, March 30, 2025 at 1:04 AM
      // Location: Kochi, Kerala, India

      // Global variables
      let camera, scene, renderer;
      let hitTestSource = null;
      let hitTestSourceRequested = false;
      let currentSession = null;
      let referenceSpace = null;
      let latestHitPoseMatrix = null;
      let selectEventPending = false;
      let placedMarkers = []; // Holds THREE.Mesh marker objects

      // --- NEW: Variables for drawing lines ---
      let lineGeometry = null;
      let lineMaterial = null;
      let measurementLines = null; // THREE.LineSegments object

      // --- State Management for Measurement ---
      let measurementState = 'idle'; // 'idle', 'waiting_bl', 'waiting_br', 'waiting_tl', 'done'
      let cornerPoints = { bl: null, br: null, tl: null }; // Stores THREE.Vector3

      // Get UI elements
      const infoDivElement = document.getElementById('info');
      const startButtonElement = document.getElementById('start-ar-button');
      const resetButtonElement = document.getElementById('reset-button');
      const canvasElement = document.getElementById('webgl-canvas');

      // --- Function Definitions (Defined ONCE) ---

      function init() {
        console.log('init() called');
        // ... (UI element checks) ...
        if (
          !infoDivElement ||
          !startButtonElement ||
          !canvasElement ||
          !resetButtonElement
        ) {
          console.error('FATAL: UI/Canvas element missing.');
          alert('UI Error.');
          return;
        }
        infoDivElement.textContent = 'Setting up Scene & Renderer...';
        try {
          scene = new THREE.Scene();
          camera = new THREE.PerspectiveCamera(
            70,
            window.innerWidth / window.innerHeight,
            0.01,
            40
          );
          renderer = new THREE.WebGLRenderer({
            canvas: canvasElement,
            alpha: true,
          }); // No AA
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.xr.enabled = true;
          console.log(
            'Three.js Renderer initialized (No Antialias), XR enabled.'
          );
          const light = new THREE.AmbientLight(0xffffff, 1.0);
          scene.add(light);
          const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
          dirLight.position.set(1, 1, 1);
          scene.add(dirLight);

          // --- NEW: Setup Line Object ---
          lineGeometry = new THREE.BufferGeometry();
          lineMaterial = new THREE.LineBasicMaterial({
            color: 0x00ffff,
            linewidth: 2,
          }); // Cyan lines
          measurementLines = new THREE.LineSegments(lineGeometry, lineMaterial);
          measurementLines.visible = false; // Initially hidden
          scene.add(measurementLines);
          console.log('Measurement line object created.');
        } catch (error) {
          console.error('Error during Three.js setup:', error);
          infoDivElement.textContent = '3D Setup Error: ' + error.message;
          displayCompatibilityError('Three.js setup failed.');
          return;
        }

        resetButtonElement.addEventListener('click', resetMeasurement);
        infoDivElement.textContent = 'Checking WebXR support...';
        checkXRSupport(); // This now enables start button via handleStartButtonClick listener setup
        window.addEventListener('resize', onWindowResize, false);
        updateInstructions();
      }

      async function checkXRSupport() {
        // (Unchanged - checks 'immersive-ar' & 'hit-test', enables button)
        console.log('checkXRSupport() called.');
        infoDivElement.textContent = 'Checking WebXR capabilities...';
        console.log('navigator.xr:', navigator.xr);
        if ('xr' in navigator && navigator.xr) {
          console.log('navigator.xr exists...');
          infoDivElement.textContent = 'Checking immersive-ar...';
          try {
            const basicSupport = await navigator.xr.isSessionSupported(
              'immersive-ar'
            );
            console.log(`Basic 'immersive-ar' supported: ${basicSupport}`);
            if (basicSupport) {
              infoDivElement.textContent = 'Checking hit-test...';
              console.log('Checking immersive-ar WITH hit-test...');
              const featureSupport = await navigator.xr.isSessionSupported(
                'immersive-ar',
                { requiredFeatures: ['hit-test'] }
              );
              console.log(
                `'immersive-ar' with 'hit-test' supported: ${featureSupport}`
              );
              if (featureSupport) {
                /* Ready state handled by updateInstructions */ startButtonElement.disabled = false;
                startButtonElement.addEventListener(
                  'click',
                  handleStartButtonClick
                );
                console.log('AR Button enabled.');
              } // Use correct handler
              else {
                infoDivElement.textContent =
                  'AR supported, but Hit Test required.';
                console.error('Hit-test feature not supported.');
                displayCompatibilityError('Hit-test feature not supported.');
              }
            } else {
              infoDivElement.textContent = 'Immersive AR not supported.';
              console.error('Basic immersive-ar not supported.');
              displayCompatibilityError('Immersive AR mode not supported.');
            }
          } catch (err) {
            infoDivElement.textContent =
              'WebXR support check Error: ' + err.message;
            console.error('Error isSessionSupported:', err);
            displayCompatibilityError(err.message);
          }
        } else {
          infoDivElement.textContent = 'WebXR API not found.';
          console.error('navigator.xr object not found.');
          displayCompatibilityError('WebXR API not available.');
        }
        updateInstructions();
      }

      function displayCompatibilityError(message) {
        console.error('Compatibility Error:', message);
        startButtonElement.disabled = true;
        measurementState = 'error';
        updateInstructions();
      }

      function handleStartButtonClick() {
        // Starts the AR session if not already started
        if (!currentSession) {
          startARSession();
        }
      }

      async function startARSession() {
        // (Unchanged - requests session)
        infoDivElement.textContent = 'Starting AR session...';
        startButtonElement.disabled = true;
        startButtonElement.style.display = 'none';
        console.log('Attempting startARSession...');
        if (currentSession) {
          console.warn('Session active? Ending.');
          try {
            await currentSession.end();
          } catch (e) {}
          currentSession = null;
        }
        try {
          currentSession = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['hit-test'],
          });
          console.log('requestSession succeeded.');
          onSessionStarted(currentSession);
        } catch (error) {
          console.error('Failed startARSession:', error);
          infoDivElement.textContent = `Failed AR Start: ${error.message}`;
          startButtonElement.style.display = 'block';
          startButtonElement.disabled = false;
          measurementState = 'idle';
          updateInstructions();
        }
      }

      async function onSessionStarted(session) {
        // (Unchanged - Sets up session, reference space, hit test)
        console.log('onSessionStarted called.');
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);
        console.log("'select' event listener added.");
        try {
          console.log("Setting hint 'local'...");
          renderer.xr.setReferenceSpaceType('local');
          console.log('Hint set.');
          console.log('Attempting setSession...');
          await renderer.xr.setSession(session);
          console.log('Successfully set renderer XR session.');
        } catch (err) {
          console.error('Error setSession:', err);
          infoDivElement.textContent = 'Fatal: Link renderer error.';
          try {
            await session.end();
          } catch (e) {}
          return;
        }
        referenceSpace = renderer.xr.getReferenceSpace();
        if (!referenceSpace) {
          console.error('Failed get ref space.');
          infoDivElement.textContent = 'Fatal: No coordinate system.';
          try {
            await session.end();
          } catch (e) {}
          return;
        }
        console.log(`Using reference space from Three.js (requested 'local').`);
        hitTestSource = null;
        hitTestSourceRequested = false;
        try {
          console.log("Attempt 'viewer' space...");
          const viewerSpace = await session.requestReferenceSpace('viewer');
          console.log("Got 'viewer' space.");
          console.log('Attempt hit source...');
          hitTestSource = await session.requestHitTestSource({
            space: viewerSpace,
          });
          hitTestSourceRequested = true;
          console.log('Hit source obtained.');
        } catch (err) {
          console.error(`Hit test setup error: ${err.message}`);
          infoDivElement.textContent = `Warning: Hit-Test setup failed: ${err.message}`;
          hitTestSourceRequested = false;
        }

        // Start measurement process
        resetMeasurement(false); // Reset state without ending session
        measurementState = 'waiting_bl'; // Start waiting for bottom-left
        updateInstructions();
        resetButtonElement.style.display = 'inline-block';
        startButtonElement.style.display = 'none';

        if (referenceSpace) {
          renderer.setAnimationLoop(onXRFrame);
          console.log('Three.js Render Loop started.');
        } else {
          console.error('Cannot start render loop without referenceSpace.');
        }
      }

      function onSessionEnded(/*event*/) {
        // (Unchanged - stops loop, resets state)
        console.log('onSessionEnded called.');
        currentSession?.removeEventListener('select', onSelect);
        currentSession = null;
        hitTestSourceRequested = false;
        hitTestSource = null;
        referenceSpace = null;
        try {
          renderer.setAnimationLoop(null);
          console.log('Three.js Render Loop stopped.');
        } catch (error) {
          console.error('Error stopping loop:', error);
        }
        resetMeasurement(true); // Full reset
        console.log('AR Session Ended.');
      }

      function onWindowResize() {
        /* ... unchanged ... */
      }
      function onSelect(event) {
        /* ... unchanged ... */
      }

      // --- Reset Measurement State ---
      function resetMeasurement(isSessionEnding = false) {
        console.log('Resetting measurement...');
        cornerPoints.bl = null;
        cornerPoints.br = null;
        cornerPoints.tl = null;
        placedMarkers.forEach((marker) => {
          scene.remove(marker);
        });
        placedMarkers = [];

        // --- NEW: Hide lines ---
        measurementLines.visible = false;

        if (isSessionEnding) {
          measurementState = 'idle';
          startButtonElement.disabled = !navigator.xr;
          startButtonElement.style.display = 'inline-block';
          resetButtonElement.style.display = 'none';
        } else if (currentSession) {
          measurementState = 'waiting_bl';
          resetButtonElement.style.display = 'inline-block';
          startButtonElement.style.display = 'none';
        }
        updateInstructions();
      }

      // --- Update Instructions UI ---
      function updateInstructions() {
        let text = '';
        switch (measurementState) {
          case 'idle':
            text = startButtonElement.disabled
              ? 'WebXR not supported or Hit Test unavailable.'
              : 'Click "Start Measurement" to begin.';
            break;
          case 'waiting_bl':
            text = 'Aim and Tap the FRONT BOTTOM-LEFT corner.';
            break;
          case 'waiting_br':
            text = 'Tap the FRONT BOTTOM-RIGHT corner.';
            break;
          case 'waiting_tl':
            text = 'Tap the FRONT TOP-LEFT corner.';
            break;
          case 'done':
            // --- NEW: Calculate and display results ---
            const dimensions = calculateDimensions(cornerPoints);
            if (dimensions) {
              text = `Measurement: W: ${dimensions.width.toFixed(
                3
              )}m, H: ${dimensions.height.toFixed(3)}m. Click Reset.`;
              // Add Depth later if calculated
            } else {
              text = 'Points collected, but calculation failed. Click Reset.';
            }
            break;
          case 'error':
            text = infoDivElement.textContent;
            break; // Keep error message
          default:
            text = 'Initializing...';
        }
        infoDivElement.textContent = text;

        // Update button visibility based on state
        if (currentSession) {
          startButtonElement.style.display = 'none';
          resetButtonElement.style.display = 'inline-block';
        } else {
          startButtonElement.textContent = 'Start Measurement';
          startButtonElement.style.display = 'inline-block';
          resetButtonElement.style.display = 'none';
        }
      }

      // --- NEW: Calculate Dimensions ---
      function calculateDimensions(points) {
        if (points.bl && points.br && points.tl) {
          try {
            const width = points.bl.distanceTo(points.br);
            const height = points.bl.distanceTo(points.tl);
            // Basic calculation assumes tapped points form the primary width/height vectors
            // More complex calculation needed if points are not perfectly aligned
            // Depth calculation requires a 4th point
            console.log(`Calculated Dimensions - W: ${width}, H: ${height}`);
            return { width, height };
          } catch (error) {
            console.error('Error calculating dimensions:', error);
            return null;
          }
        }
        return null; // Not enough points
      }

      // --- NEW: Update Measured Lines ---
      function updateMeasuredLines(points) {
        const vertices = [];
        let linesVisible = false;

        // Draw line BL -> BR (Width)
        if (points.bl && points.br) {
          vertices.push(points.bl.x, points.bl.y, points.bl.z);
          vertices.push(points.br.x, points.br.y, points.br.z);
          linesVisible = true;
        }
        // Draw line BL -> TL (Height)
        if (points.bl && points.tl) {
          vertices.push(points.bl.x, points.bl.y, points.bl.z);
          vertices.push(points.tl.x, points.tl.y, points.tl.z);
          linesVisible = true;
        }
        // TODO: Add lines for the other two sides of the front face later
        // Requires calculating the 4th corner (TR) = BR + (TL - BL)

        if (linesVisible) {
          lineGeometry.setAttribute(
            'position',
            new THREE.Float32BufferAttribute(vertices, 3)
          );
          lineGeometry.computeBoundingSphere(); // Needed for proper rendering
          measurementLines.visible = true;
          console.log(
            `Updated measurement lines with ${vertices.length / 3} vertices.`
          );
        } else {
          measurementLines.visible = false;
        }
      }

      // --- onXRFrame - Render Loop ---
      // --- REVISED onXRFrame - More Logging ---
      function onXRFrame(timestamp, frame) {
        if (!frame) {
          return;
        }
        latestHitPoseMatrix = null; // Reset hit pose for this frame

        // Get Hit Test Results (Unchanged)
        if (hitTestSourceRequested && hitTestSource && referenceSpace) {
          try {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const hitPose = hit.getPose(referenceSpace);
              if (hitPose) {
                latestHitPoseMatrix = hitPose.transform.matrix;
              }
            }
          } catch (error) {
            /* Ignore */
          }
        }

        // Process Pending Select Event Based on State
        if (selectEventPending) {
          console.log(`DEBUG: Processing select in state: ${measurementState}`); // Log entry and state

          if (latestHitPoseMatrix) {
            console.log('DEBUG: Hit detected! Matrix available.'); // Log hit success

            // Place a marker visually FIRST
            console.log('DEBUG: Calling placeMarker...');
            const markerPosition = placeMarker(latestHitPoseMatrix);
            console.log(
              'DEBUG: placeMarker returned position:',
              markerPosition
            );

            if (!markerPosition) {
              console.error(
                'DEBUG: placeMarker did not return a valid position!'
              );
              selectEventPending = false; // Reset flag even on error
              return; // Stop processing this tap
            }

            // Store point based on current state
            let pointStored = false;
            let justCompleted = false; // Flag if measurement finished this tap

            console.log('DEBUG: Entering state switch for:', measurementState);
            switch (measurementState) {
              case 'waiting_bl':
                console.log('DEBUG: State matched: waiting_bl');
                cornerPoints.bl = markerPosition;
                measurementState = 'waiting_br';
                pointStored = true;
                break;
              case 'waiting_br':
                console.log('DEBUG: State matched: waiting_br');
                cornerPoints.br = markerPosition;
                measurementState = 'waiting_tl';
                pointStored = true;
                break;
              case 'waiting_tl':
                console.log('DEBUG: State matched: waiting_tl');
                cornerPoints.tl = markerPosition;
                measurementState = 'done'; // Finished collecting points for W/H
                pointStored = true;
                justCompleted = true;
                break;
              // Add case for 'waiting_back' later
              default:
                console.warn(
                  'DEBUG: Tap occurred in unexpected/unhandled state:',
                  measurementState
                );
                // Don't store point if state is unexpected (like 'idle' or 'done')
                break;
            }

            if (pointStored) {
              console.log(
                'DEBUG: Stored point successfully. New state:',
                measurementState
              );
              console.log('DEBUG: Calling updateMeasuredLines...');
              updateMeasuredLines(cornerPoints); // Update lines immediately
              console.log('DEBUG: Calling updateInstructions...');
              updateInstructions(); // Update instructions for next step / display results
              if (justCompleted) {
                console.log('DEBUG: Measurement points complete.');
              }
            } else {
              console.log(
                "DEBUG: Point not stored (state was likely 'idle' or 'done')."
              );
              // Maybe provide feedback if user taps when 'done'?
              if (measurementState === 'done') {
                infoDivElement.textContent =
                  'Measurement complete. Click Reset to start again.';
              }
            }
          } else {
            // No hit detected on tap
            console.log('DEBUG: No hit pose found for this tap.'); // Log hit failure
            const currentInstructions = infoDivElement.textContent;
            // Avoid appending multiple times if user taps rapidly
            if (!currentInstructions.endsWith('(No surface hit!)')) {
              infoDivElement.textContent =
                currentInstructions + ' (No surface hit!)';
            }
            setTimeout(() => {
              // Revert message after delay only if state hasn't changed
              // Check if the message is still the one we added
              const expectedMessage =
                currentInstructions + ' (No surface hit!)';
              if (infoDivElement.textContent === expectedMessage) {
                console.log("DEBUG: Reverting 'No surface hit' message.");
                updateInstructions(); // Revert to standard instruction
              }
            }, 1500);
          }
          selectEventPending = false; // Reset flag AFTER processing
          console.log('DEBUG: selectEventPending reset to false.');
        }

        // Render (Unchanged)
        try {
          renderer.render(scene, camera);
        } catch (error) {
          console.error('Render error:', error);
        }
      }

      // --- Full Code ---
      // Replace the existing onXRFrame function in the previous full code block
      // with this updated version. Ensure all other functions remain the same.
      if (!frame) {
        return;
      }
      latestHitPoseMatrix = null;

      // Get Hit Test Results
      if (hitTestSourceRequested && hitTestSource && referenceSpace) {
        try {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            const hitPose = hit.getPose(referenceSpace);
            if (hitPose) {
              latestHitPoseMatrix = hitPose.transform.matrix;
            }
          }
        } catch (error) {
          /* Ignore */
        }
      }

      // Process Pending Select Event Based on State
      if (selectEventPending) {
        console.log(`Processing select in state: ${measurementState}`);
        if (latestHitPoseMatrix) {
          const markerPosition = placeMarker(latestHitPoseMatrix);
          let pointStored = false;
          let justCompleted = false; // Flag if measurement finished this tap

          switch (measurementState) {
            case 'waiting_bl':
              cornerPoints.bl = markerPosition;
              measurementState = 'waiting_br';
              pointStored = true;
              break;
            case 'waiting_br':
              cornerPoints.br = markerPosition;
              measurementState = 'waiting_tl';
              pointStored = true;
              break;
            case 'waiting_tl':
              cornerPoints.tl = markerPosition;
              measurementState = 'done'; // Finished collecting points for W/H
              pointStored = true;
              justCompleted = true; // Signal completion
              break;
          }

          if (pointStored) {
            console.log(
              'Stored point for state:',
              Object.keys(cornerPoints).find(
                (key) => cornerPoints[key] === markerPosition
              )
            );
            updateMeasuredLines(cornerPoints); // Update lines immediately
            // Update instructions AFTER lines/calculations
            if (justCompleted) {
              // Calculations happen via updateInstructions when state is 'done'
              console.log('Measurement points complete.');
            }
            updateInstructions();
          } else {
            console.log('Tap in unexpected state:', measurementState);
          }
        } else {
          const currentInstructions = infoDivElement.textContent;
          infoDivElement.textContent =
            currentInstructions + ' (No surface hit!)';
          console.log('No hit pose on tap.');
          setTimeout(() => {
            // Revert message after delay only if state hasn't changed
            if (
              infoDivElement.textContent ===
              currentInstructions + ' (No surface hit!)'
            ) {
              updateInstructions();
            }
          }, 1500); // Increased delay
        }
        selectEventPending = false;
      }

      // Render
      try {
        renderer.render(scene, camera);
      } catch (error) {
        console.error('Render error:', error);
      }

      // Place Marker Helper (Unchanged - returns position)
      function placeMarker(matrixArray) {
        const geometry = new THREE.SphereGeometry(0.02, 16, 16);
        const material = new THREE.MeshStandardMaterial({
          color: 0x00ff00,
          roughness: 0.4,
          metalness: 0.1,
        }); // Green
        const marker = new THREE.Mesh(geometry, material);
        marker.matrix.fromArray(matrixArray);
        marker.matrix.decompose(
          marker.position,
          marker.quaternion,
          marker.scale
        );
        marker.scale.set(1, 1, 1);
        scene.add(marker);
        placedMarkers.push(marker);
        console.log(
          `Placed marker #${placedMarkers.length}:`,
          marker.position.x.toFixed(3),
          marker.position.y.toFixed(3),
          marker.position.z.toFixed(3)
        );
        return marker.position.clone();
      }

      // --- Start the application ---
      document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM Ready.');
        init();
      });
      console.log(
        '--- JS module execution finished (Visualize & Calculate) ---'
      );
    </script>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>
      eruda.init();
    </script>
  </body>
</html>
