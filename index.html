<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>WebXR Core Test + Min GL Layer</title>
    <style>
      /* CSS styles remain the same */
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: #000;
        color: white;
      }
      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display: block;
        color: white;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        font-size: 16px;
        box-sizing: border-box;
      }
      #start-ar-button {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        padding: 14px 28px;
        font-size: 18px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        z-index: 101;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        transition: background-color 0.3s ease;
      }
      #start-ar-button:disabled {
        background-color: #555;
        color: #aaa;
        cursor: not-allowed;
        box-shadow: none;
      }
      #start-ar-button:hover:not(:disabled) {
        background-color: #0056b3;
      }
      /* *** ADD CANVAS STYLE *** */
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <div id="info">Initializing...</div>
    <button id="start-ar-button" disabled>Start Core AR Test</button>
    <canvas id="webgl-canvas"></canvas>

    <script type="module">
      console.log('--- JavaScript module execution started (Min WebGL) ---');

      // --- Relevant Context ---
      // Current time: Friday, March 28, 2025 at 6:29 PM
      // Location: Kochi, Kerala, India

      // Global variables
      let gl = null; // WebGL rendering context
      let xrWebGLLayer = null;
      let hitTestSource = null;
      let hitTestSourceRequested = false;
      let currentSession = null;
      let referenceSpace = null;
      let xrFrameLoopActive = false;
      let latestHitPoseMatrix = null;
      let selectEventPending = false;

      // Get UI elements & Canvas
      const infoDivElement = document.getElementById('info');
      const startButtonElement = document.getElementById('start-ar-button');
      const canvasElement = document.getElementById('webgl-canvas'); // Get canvas

      // --- Initialization ---
      function init() {
        console.log('init() called');
        if (!infoDivElement || !startButtonElement || !canvasElement) {
          console.error('FATAL: UI or Canvas element not found!');
          alert('Error: UI element not found.');
          return;
        }

        infoDivElement.textContent = 'Setting up WebGL...';

        // --- Minimal WebGL Context Setup ---
        try {
          // Try for WebGL2, fallback to WebGL1
          gl = canvasElement.getContext('webgl2', { xrCompatible: true });
          if (!gl) {
            console.log('WebGL2 not supported, trying WebGL1');
            gl = canvasElement.getContext('webgl', { xrCompatible: true });
          }
          if (!gl) {
            throw new Error(
              'WebGL is not supported or xrCompatible context failed.'
            );
          }
          console.log('WebGL context obtained successfully (xrCompatible).');

          // Basic GL setup (optional but good practice)
          gl.clearColor(0.0, 0.0, 0.0, 0.0); // Transparent black
          gl.enable(gl.DEPTH_TEST);
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        } catch (error) {
          console.error('Error getting WebGL context:', error);
          infoDivElement.textContent =
            'Error initializing WebGL: ' + error.message;
          displayCompatibilityError('WebGL initialization failed.');
          return; // Stop if WebGL fails
        }

        infoDivElement.textContent = 'Checking WebXR support...';
        checkXRSupport();
        window.addEventListener('resize', onWindowResize, false);
      }

      // --- WebXR Support Check --- (Unchanged logic)
      async function checkXRSupport() {
        /* ... same as before ... */
      }
      function displayCompatibilityError(message) {
        console.error('Compatibility Error:', message);
        startButtonElement.disabled = true;
      }

      // --- WebXR Session Management ---
      async function startARSession() {
        /* ... same as before ... */
      }

      async function onSessionStarted(session) {
        infoDivElement.textContent =
          'AR Session Active. Configuring render state...';
        console.log('onSessionStarted called.');
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);
        console.log("'select' event listener added.");

        // --- ** Link WebGL context to WebXR session ** ---
        if (!gl) {
          console.error('WebGL context is missing!');
          infoDivElement.textContent = 'Error: WebGL context lost.';
          try {
            await session.end();
          } catch (e) {}
          return;
        }
        try {
          console.log('Attempting to create XRWebGLLayer...');
          xrWebGLLayer = new XRWebGLLayer(session, gl);
          console.log('XRWebGLLayer created.');

          console.log('Attempting session.updateRenderState...');
          // Set the layer as the source for composition
          await session.updateRenderState({ baseLayer: xrWebGLLayer });
          console.log('Session render state updated with baseLayer.');

          // Adjust canvas size to match XR layer (important!)
          canvasElement.width = xrWebGLLayer.framebufferWidth;
          canvasElement.height = xrWebGLLayer.framebufferHeight;
          console.log(
            'Canvas resized to XR framebuffer:',
            canvasElement.width,
            'x',
            canvasElement.height
          );
        } catch (error) {
          console.error(
            'Error setting up XRWebGLLayer or Render State:',
            error
          );
          infoDivElement.textContent =
            'Error setting up WebGL layer for AR: ' + error.message;
          try {
            await session.end();
          } catch (e) {}
          return;
        }
        // --- End WebGL Linking ---

        // --- Request Reference Space --- (Unchanged logic)
        /* ... same as before ... */

        // --- Request Hit Test Source --- (Unchanged logic)
        /* ... same as before ... */

        // --- Start Frame Loop ---
        if (referenceSpace) {
          xrFrameLoopActive = true;
          session.requestAnimationFrame(onXRFrame);
          console.log('XR Frame Loop started.');
        } else {
          console.error('Cannot start frame loop without referenceSpace.');
        }
      }

      function onSessionEnded(/*event*/) {
        /* ... same cleanup as before ... */
      }

      // --- Event Handlers ---
      function onWindowResize() {
        /* Can be empty for now */
      }
      function onSelect(event) {
        /* ... same as before ... */
      }

      // --- XR Frame Loop ---
      function onXRFrame(timestamp, frame) {
        if (!currentSession || !xrFrameLoopActive) {
          console.log('Exiting frame loop.');
          return;
        }

        session = frame.session; // Get session from frame
        session.requestAnimationFrame(onXRFrame); // Re-queue next frame

        // --- ** Prepare GL for drawing to the XR Layer ** ---
        if (!xrWebGLLayer || !gl) {
          console.error('Missing GL or Layer in frame loop');
          return;
        }
        try {
          // Bind the framebuffer provided by the XR session's layer
          gl.bindFramebuffer(gl.FRAMEBUFFER, xrWebGLLayer.framebuffer);

          // Get the viewport for this frame (can change if rendering per-eye)
          // For inline/magic window AR, there's usually one view
          const pose = frame.getViewerPose(referenceSpace);
          if (pose) {
            // Typically iterate through pose.views here
            for (const view of pose.views) {
              const viewport = xrWebGLLayer.getViewport(view);
              if (!viewport) continue; // Skip if viewport is invalid

              // Set the WebGL viewport to match the XR view
              gl.viewport(
                viewport.x,
                viewport.y,
                viewport.width,
                viewport.height
              );

              // ** Clear the viewport **
              // Although we draw nothing, clearing ensures the compositor gets updated
              // Use transparent black (0,0,0,0) so camera shows through
              gl.clearColor(0, 0, 0, 0);
              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

              // *** If we WERE drawing, it would happen here, using view.projectionMatrix and view.transform ***
            }
          } else {
            // console.warn("No viewer pose this frame."); // Can happen
            // Still might need to clear if layer exists? Let's clear outside pose check just in case.
            // gl.clearColor(0, 0, 0, 0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          }
        } catch (error) {
          console.error('Error during GL preparation in frame loop:', error);
          // Consider stopping loop if errors persist
        }
        // --- End GL Prep ---

        // --- Handle Hit Testing --- (Unchanged logic)
        /* ... same as before ... */

        // --- Process Pending Select Event --- (Unchanged logic)
        /* ... same as before ... */
      }

      // --- Start the application ---
      document.addEventListener('DOMContentLoaded', () => {
        console.log('Event: DOMContentLoaded fired.');
        init();
      });
      console.log('--- JavaScript module execution finished (Min WebGL) ---');

      // --- Unchanged/Previously Omitted Functions (for completeness) ---
      async function checkXRSupport() {
        console.log('checkXRSupport() called.');
        infoDivElement.textContent = 'Checking WebXR capabilities...';
        console.log('navigator.xr:', navigator.xr);
        if ('xr' in navigator && navigator.xr) {
          console.log('navigator.xr exists. Checking session support...');
          infoDivElement.textContent = 'Checking for immersive-ar support...';
          try {
            const basicSupport = await navigator.xr.isSessionSupported(
              'immersive-ar'
            );
            console.log(`Basic 'immersive-ar' supported: ${basicSupport}`);
            if (basicSupport) {
              infoDivElement.textContent = 'Checking for hit-test feature...';
              console.log('Checking support for immersive-ar WITH hit-test...');
              const featureSupport = await navigator.xr.isSessionSupported(
                'immersive-ar',
                { requiredFeatures: ['hit-test'] }
              );
              console.log(
                `'immersive-ar' with 'hit-test' supported: ${featureSupport}`
              );
              if (featureSupport) {
                infoDivElement.textContent =
                  'Ready! Click "Start Core AR Test"';
                startButtonElement.disabled = false;
                startButtonElement.addEventListener('click', startARSession);
                console.log('AR Button enabled.');
              } else {
                infoDivElement.textContent =
                  'AR supported, but Hit Test feature is not.';
                console.error('Hit-test feature not supported.');
                displayCompatibilityError('Hit-test feature not supported.');
              }
            } else {
              infoDivElement.textContent = 'Immersive AR mode not supported.';
              console.error('Basic immersive-ar not supported.');
              displayCompatibilityError('Immersive AR mode not supported.');
            }
          } catch (err) {
            infoDivElement.textContent =
              'Error during WebXR support check: ' + err.message;
            console.error('Error calling isSessionSupported:', err);
            displayCompatibilityError(err.message);
          }
        } else {
          infoDivElement.textContent = 'WebXR API not found.';
          console.error('navigator.xr object not found.');
          displayCompatibilityError('WebXR API not available.');
        }
      }
      async function startARSession() {
        infoDivElement.textContent = 'Starting AR session...';
        startButtonElement.disabled = true;
        startButtonElement.style.display = 'none';
        console.log('Attempting to start AR session...');
        if (currentSession) {
          console.warn('Session already active? Ending previous.');
          try {
            await currentSession.end();
          } catch (e) {
            console.error('Error ending previous session:', e);
          }
          currentSession = null;
        }
        try {
          currentSession = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['hit-test'],
          });
          console.log('navigator.xr.requestSession succeeded.');
          onSessionStarted(currentSession);
        } catch (error) {
          console.error('Failed to start AR session:', error);
          infoDivElement.textContent = `Failed to start AR: ${error.message}. Check permissions.`;
          startButtonElement.style.display = 'block';
          startButtonElement.disabled = false;
        }
      }
      async function onSessionEnded(/*event*/) {
        console.log('onSessionEnded called.');
        xrFrameLoopActive = false;
        currentSession?.removeEventListener('select', onSelect); // Use optional chaining
        currentSession = null;
        hitTestSourceRequested = false;
        hitTestSource = null;
        referenceSpace = null;
        xrWebGLLayer = null; // Clear GL layer ref
        infoDivElement.textContent =
          'AR Session ended. Click Start to begin again.';
        startButtonElement.style.display = 'block';
        startButtonElement.disabled = false;
        console.log('AR Session Ended.');
        // Reset canvas size? Optional.
        // canvasElement.width = canvasElement.clientWidth * window.devicePixelRatio;
        // canvasElement.height = canvasElement.clientHeight * window.devicePixelRatio;
      }
      function onSelect(event) {
        console.log('Select event detected on session.');
        selectEventPending = true; /* infoDivElement.textContent = 'Tap registered!'; */
      } // Removed UI update here
      // Frame Loop Logic for hit test and select processing
      function processFrameHitsAndSelect(frame) {
        latestHitPoseMatrix = null;
        if (hitTestSourceRequested && hitTestSource && referenceSpace) {
          try {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const hitPose = hit.getPose(referenceSpace);
              if (hitPose) {
                latestHitPoseMatrix = hitPose.transform.matrix;
              }
            }
          } catch (error) {}
        }
        if (selectEventPending) {
          console.log('Processing pending select event...');
          if (latestHitPoseMatrix) {
            const position = {
              x: latestHitPoseMatrix[12].toFixed(3),
              y: latestHitPoseMatrix[13].toFixed(3),
              z: latestHitPoseMatrix[14].toFixed(3),
            };
            infoDivElement.textContent = `Hit detected at ~ X:${position.x}, Y:${position.y}, Z:${position.z}`;
            console.log('>>> Hit Placement <<< Matrix:', latestHitPoseMatrix);
          } else {
            infoDivElement.textContent =
              'Tap processed, but no surface hit detected this frame.';
            console.log('Tap processed, but no valid hit pose found.');
          }
          selectEventPending = false;
        }
      }
      // Add call inside onXRFrame:
      function onXRFrame(timestamp, frame) {
        /* ... session active check ... */
        session = frame.session;
        session.requestAnimationFrame(onXRFrame);
        /* ... GL preparation ... */
        if (gl && xrWebGLLayer) {
          /* ... bind framebuffer, clear buffer ... */
          gl.bindFramebuffer(gl.FRAMEBUFFER, xrWebGLLayer.framebuffer);
          const pose = frame.getViewerPose(referenceSpace);
          if (pose) {
            for (const view of pose.views) {
              const viewport = xrWebGLLayer.getViewport(view);
              if (!viewport) continue;
              gl.viewport(
                viewport.x,
                viewport.y,
                viewport.width,
                viewport.height
              );
              gl.clearColor(0, 0, 0, 0);
              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            }
          } else {
            // Fallback clear if pose lost? Might not be needed if layer handles it.
            // gl.clearColor(0, 0, 0, 0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          }
        }
        processFrameHitsAndSelect(frame); // Call hit test/select logic
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>
      eruda.init();
    </script>
  </body>
</html>
