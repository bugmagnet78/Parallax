<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>WebXR + MediaPipe Objectron (Corrected)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: #000;
        color: white;
      }
      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display: block;
        color: white;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        font-size: 16px;
        box-sizing: border-box;
        min-height: 3em;
      }
      .button-container {
        position: absolute;
        bottom: 30px;
        width: 100%;
        text-align: center;
        z-index: 101;
      }
      .button-container button {
        padding: 12px 24px;
        font-size: 16px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        transition: background-color 0.3s ease;
      }
      .button-container button:disabled {
        background-color: #555;
        color: #aaa;
        cursor: not-allowed;
        box-shadow: none;
      }
      .button-container button:hover:not(:disabled) {
        background-color: #0056b3;
      }
      canvas#webgl-canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }
      video#input-video {
        display: none;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
        }
      }
    </script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/objectron/objectron.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="info">Initializing...</div>
    <div class="button-container">
      <button id="start-ar-button" disabled>Start AR Objectron</button>
    </div>
    <video id="input-video"></video>
    <canvas id="webgl-canvas"></canvas>

    <script type="module">
      console.log(
        '--- JavaScript module execution started (Objectron Corrected) ---'
      );

      import * as THREE from 'three';

      console.log('Three.js imported:', THREE ? 'Yes' : 'No');
      console.log(
        'MediaPipe Objectron available:',
        window.Objectron ? 'Yes' : 'No'
      );

      // --- Relevant Context ---
      // Current time: Sunday, March 30, 2025 at 3:41 PM
      // Location: Kochi, Kerala, India

      // Global variables
      let camera, scene, renderer; // Three.js
      let currentSession = null; // WebXR
      let referenceSpace = null;
      let objectron = null; // MediaPipe
      let cameraHelper = null; // MediaPipe Camera Util
      let latestObjectronResult = null; // Store detection result
      let objectronBoundingBox = null; // Three.js Box Helper

      const infoDivElement = document.getElementById('info');
      const startButtonElement = document.getElementById('start-ar-button');
      const videoElement = document.getElementById('input-video');
      const canvasElement = document.getElementById('webgl-canvas');

      // --- Function Definitions (Defined ONCE Each) ---

      async function init() {
        console.log('init() called');
        // --- Ensure Elements Exist ---
        if (
          !infoDivElement ||
          !startButtonElement ||
          !canvasElement ||
          !videoElement ||
          !window.Objectron
        ) {
          console.error(
            'FATAL: UI/Canvas/Video/Objectron missing or MP not loaded.'
          );
          infoDivElement.textContent =
            'Error: Required elements or MediaPipe Objectron not loaded.';
          if (startButtonElement) startButtonElement.disabled = true;
          return; // Stop initialization
        }

        infoDivElement.textContent = 'Setting up Scene & Renderer...';
        // --- Three.js Setup ---
        try {
          scene = new THREE.Scene();
          camera = new THREE.PerspectiveCamera(
            70,
            window.innerWidth / window.innerHeight,
            0.01,
            40
          );
          renderer = new THREE.WebGLRenderer({
            canvas: canvasElement,
            antialias: true,
            alpha: true,
          });
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.xr.enabled = true;
          console.log('Three.js Renderer initialized, XR enabled.');
          const light = new THREE.AmbientLight(0xffffff, 1.0);
          scene.add(light);
          const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
          dirLight.position.set(1, 1, 1);
          scene.add(dirLight);
          const initialBox = new THREE.Box3(
            new THREE.Vector3(-0.1, -0.1, -0.1),
            new THREE.Vector3(0.1, 0.1, 0.1)
          );
          objectronBoundingBox = new THREE.Box3Helper(initialBox, 0xffff00);
          objectronBoundingBox.visible = false;
          scene.add(objectronBoundingBox);
          console.log('Objectron bounding box helper created.');
        } catch (error) {
          console.error('Init Error:', error);
          displayCompatibilityError('3D Setup failed: ' + error.message);
          return;
        }

        // --- MediaPipe Objectron Setup ---
        infoDivElement.textContent = 'Loading Objectron Model...';
        try {
          objectron = new Objectron({
            locateFile: (file) => {
              console.log(`Locating file: ${file}`);
              // *** CHANGE: Consistently use the older v0.4 path ***
              const objectronBasePath =
                'https://cdn.jsdelivr.net/npm/@mediapipe/objectron@0.4/';
              // Check if the file requested is one of the core WASM/data files
              // This might need adjustment based on exact filenames Objectron requests
              if (
                file.endsWith('.wasm') ||
                file.endsWith('.data') ||
                file.endsWith('.js') ||
                file.endsWith('.binarypb')
              ) {
                return `${objectronBasePath}${file}`;
              }
              // Otherwise, assume it might be a model file (if not bundled)
              // If models are separate, you might need logic to return their specific path here.
              // For now, assume models are loaded implicitly or bundled within the main files.
              console.warn(
                `Unsure how to locate model file: ${file}, assuming bundled.`
              );
              // Return the base path anyway, maybe it resolves internally?
              return `${objectronBasePath}${file}`;
            },
          });
          console.log('Objectron instance created.');

          objectron.setOptions({
            staticImageMode: false,
            // --- IMPORTANT: Ensure this matches the object you test ---
            modelName: 'Shoe', // Or 'Chair', 'Cup', 'Camera'
            //---------------------------------------------------------
            maxNumObjects: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.7,
          });
          console.log(
            `Objectron options set (Model: ${objectron.options.modelName}).`
          ); // Log the model used

          objectron.onResults(onObjectronResults);
          console.log('Objectron results callback set.');
        } catch (error) {
          console.error('MediaPipe Init Error:', error);
          displayCompatibilityError('MediaPipe setup failed: ' + error.message);
          return;
        }

        // --- Camera Setup ---
        infoDivElement.textContent = 'Setting up Camera...';
        try {
          cameraHelper = new Camera(videoElement, {
            onFrame: async () => {
              await objectron.send({ image: videoElement });
            },
            width: 640,
            height: 480,
          });
          await cameraHelper.start();
          console.log('MediaPipe Camera util started.');
          infoDivElement.textContent = 'Camera OK. Checking WebXR...';
        } catch (error) {
          console.error('Camera Setup Error:', error);
          displayCompatibilityError('Camera setup failed: ' + error.message);
          return;
        }

        // --- Check WebXR Support ---
        checkXRSupport();
        window.addEventListener('resize', onWindowResize, false);
      }
      console.log('init() called');
      if (
        !infoDivElement ||
        !startButtonElement ||
        !canvasElement ||
        !videoElement ||
        !window.Objectron
      ) {
        console.error(
          'FATAL: UI/Canvas/Video/Objectron missing or MP not loaded.'
        );
        infoDivElement.textContent =
          'Error: Required elements or MediaPipe Objectron not loaded.';
        if (startButtonElement) startButtonElement.disabled = true;
        return; // OK Return
      }

      infoDivElement.textContent = 'Setting up Scene & Renderer...';
      try {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          40
        );
        // Re-adding antialias: true as it wasn't the cause of the previous error
        renderer = new THREE.WebGLRenderer({
          canvas: canvasElement,
          antialias: true,
          alpha: true,
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        console.log('Three.js Renderer initialized, XR enabled.');
        const light = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(light);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(1, 1, 1);
        scene.add(dirLight);
        const initialBox = new THREE.Box3(
          new THREE.Vector3(-0.1, -0.1, -0.1),
          new THREE.Vector3(0.1, 0.1, 0.1)
        );
        objectronBoundingBox = new THREE.Box3Helper(initialBox, 0xffff00); // Yellow
        objectronBoundingBox.visible = false;
        scene.add(objectronBoundingBox);
        console.log('Objectron bounding box helper created.');
      } catch (error) {
        console.error('Init Error:', error);
        displayCompatibilityError('3D Setup failed: ' + error.message);
        return; // OK Return
      }

      infoDivElement.textContent = 'Loading Objectron Model...';
      try {
        objectron = new Objectron({
          locateFile: (file) => {
            console.log(`Locating file: ${file}`);
            // Assuming WASM files are in this path for the legacy Objectron package
            return `https://cdn.jsdelivr.net/npm/@mediapipe/objectron@0.4/${file}`;
          },
        });
        console.log('Objectron instance created.');

        objectron.setOptions({
          staticImageMode: false,
          modelName: 'Shoe', // Or 'Chair', 'Cup', 'Camera'
          maxNumObjects: 1,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.7,
        });
        console.log('Objectron options set (Model: Shoe).');

        objectron.onResults(onObjectronResults);
        console.log('Objectron results callback set.');
      } catch (error) {
        console.error('MediaPipe Init Error:', error);
        displayCompatibilityError('MediaPipe setup failed: ' + error.message);
        return; // OK Return
      }

      infoDivElement.textContent = 'Setting up Camera...';
      try {
        cameraHelper = new Camera(videoElement, {
          onFrame: async () => {
            await objectron.send({ image: videoElement });
          },
          width: 640,
          height: 480,
        });
        await cameraHelper.start();
        console.log('MediaPipe Camera util started.');
        infoDivElement.textContent = 'Camera OK. Checking WebXR...';
      } catch (error) {
        console.error('Camera Setup Error:', error);
        displayCompatibilityError('Camera setup failed: ' + error.message);
        return; // OK Return
      }

      checkXRSupport();
      window.addEventListener('resize', onWindowResize, false);

      function onObjectronResults(results) {
        if (results.objectDetections && results.objectDetections.length > 0) {
          latestObjectronResult = results.objectDetections[0];
        } else {
          latestObjectronResult = null;
        }
      }

      async function checkXRSupport() {
        console.log('checkXRSupport() called.');
        console.log('navigator.xr:', navigator.xr);
        if ('xr' in navigator && navigator.xr) {
          console.log('navigator.xr exists...');
          infoDivElement.textContent = 'Checking immersive-ar...';
          try {
            const supported = await navigator.xr.isSessionSupported(
              'immersive-ar'
            );
            console.log(`'immersive-ar' supported: ${supported}`);
            if (supported) {
              infoDivElement.textContent = 'Ready! Click "Start AR Objectron"';
              startButtonElement.disabled = false;
              startButtonElement.addEventListener(
                'click',
                handleStartButtonClick
              );
              console.log('AR Button enabled.');
            } else {
              infoDivElement.textContent = 'Immersive AR not supported.';
              displayCompatibilityError('Immersive AR not supported.');
            }
          } catch (err) {
            infoDivElement.textContent =
              'WebXR support check Error: ' + err.message;
            console.error('Error isSessionSupported:', err);
            displayCompatibilityError(err.message);
          }
        } else {
          infoDivElement.textContent = 'WebXR API not found.';
          displayCompatibilityError('WebXR API not available.');
        }
      }

      function displayCompatibilityError(message) {
        console.error('Compatibility Error:', message);
        if (startButtonElement) startButtonElement.disabled = true;
        if (infoDivElement) infoDivElement.textContent = message;
      }

      function handleStartButtonClick() {
        if (!currentSession) {
          startARSession();
        }
      }

      async function startARSession() {
        infoDivElement.textContent = 'Starting AR session...';
        startButtonElement.disabled = true;
        startButtonElement.style.display = 'none';
        console.log('Attempting startARSession...');
        if (currentSession) {
          console.warn('Session active? Ending.');
          try {
            await currentSession.end();
          } catch (e) {}
          currentSession = null;
        }
        try {
          currentSession = await navigator.xr.requestSession('immersive-ar');
          console.log('requestSession succeeded.');
          onSessionStarted(currentSession);
        } catch (error) {
          console.error('Failed startARSession:', error);
          infoDivElement.textContent = `Failed AR Start: ${error.message}`;
          startButtonElement.style.display = 'block';
          startButtonElement.disabled = false;
        }
      }

      async function onSessionStarted(session) {
        console.log('onSessionStarted called.');
        session.addEventListener('end', onSessionEnded);
        // No select listener needed now

        try {
          console.log("Setting hint 'local'...");
          renderer.xr.setReferenceSpaceType('local');
          console.log('Hint set.');
          console.log('Attempting setSession...');
          await renderer.xr.setSession(session);
          console.log('Successfully set renderer XR session.');
        } catch (err) {
          console.error('Error setSession:', err);
          infoDivElement.textContent = 'Fatal: Link renderer error.';
          try {
            await session.end();
          } catch (e) {}
          return;
        } // OK Return

        referenceSpace = renderer.xr.getReferenceSpace();
        if (!referenceSpace) {
          console.error('Failed get ref space.');
          infoDivElement.textContent = 'Fatal: No coordinate system.';
          try {
            await session.end();
          } catch (e) {}
          return;
        } // OK Return
        console.log(`Using reference space from Three.js (requested 'local').`);
        infoDivElement.textContent = 'AR Session Running. Point at a Shoe.';

        renderer.setAnimationLoop(onXRFrame);
        console.log('Three.js Render Loop started.');
      }

      function onSessionEnded(/*event*/) {
        console.log('onSessionEnded called.');
        currentSession = null;
        referenceSpace = null;
        latestObjectronResult = null;
        try {
          renderer.setAnimationLoop(null);
          console.log('Three.js Render Loop stopped.');
        } catch (error) {
          console.error('Error stopping loop:', error);
        }
        if (objectronBoundingBox) objectronBoundingBox.visible = false;
        infoDivElement.textContent = 'AR Session ended. Click Start again.';
        startButtonElement.style.display = 'inline-block';
        startButtonElement.disabled = false;
        console.log('AR Session Ended.');
        // Consider stopping camera helper cleanly if possible
      }

      function onWindowResize() {
        if (!renderer.xr.isPresenting) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      // --- onXRFrame Function (with detection logs) ---
      function onXRFrame(timestamp, frame) {
        // console.log(`onXRFrame called - Timestamp: ${timestamp}`); // Reduce spam

        if (!frame || !currentSession) {
          console.warn('onXRFrame: No frame or session.');
          return;
        } // OK Return

        try {
          const pose = frame.getViewerPose(referenceSpace);
          if (!pose) {
            renderer.render(scene, camera);
            return;
          } // OK Return if no pose
          const cameraWorldMatrix = new THREE.Matrix4().fromArray(
            pose.transform.matrix
          );

          if (latestObjectronResult) {
            // console.log("DEBUG: Objectron Result DETECTED this frame."); // Reduce spam
            const objectron_R = latestObjectronResult.rotation;
            const objectron_T = latestObjectronResult.translation;
            const objectron_S = latestObjectronResult.scale;

            // --- Transform (Needs Verification based on MP output format) ---
            const objectMatrixCamera = new THREE.Matrix4();
            objectMatrixCamera.set(
              // Assuming Column-Major 3x3 Rotation from MP -> Row-Major 4x4 for THREE
              objectron_R[0],
              objectron_R[3],
              objectron_R[6],
              objectron_T[0],
              objectron_R[1],
              objectron_R[4],
              objectron_R[7],
              objectron_T[1],
              objectron_R[2],
              objectron_R[5],
              objectron_R[8],
              objectron_T[2],
              0,
              0,
              0,
              1
            );
            const objectWorldMatrix = new THREE.Matrix4().multiplyMatrices(
              cameraWorldMatrix,
              objectMatrixCamera
            );

            // --- Update Visualizer ---
            objectronBoundingBox.matrix.copy(objectWorldMatrix);
            // Apply scale - Box3Helper is 1x1x1 centered. MP scale is full W/H/D? Assume yes for now.
            objectronBoundingBox.scale.set(
              objectron_S[0],
              objectron_S[1],
              objectron_S[2]
            );
            objectronBoundingBox.matrixAutoUpdate = false;
            objectronBoundingBox.updateMatrixWorld(true);
            objectronBoundingBox.visible = true;

            // --- Display Scale ---
            const scaleText = `Est. Scale: X:${objectron_S[0].toFixed(
              3
            )}, Y:${objectron_S[1].toFixed(3)}, Z:${objectron_S[2].toFixed(3)}`;
            if (infoDivElement.textContent !== scaleText) {
              infoDivElement.textContent = scaleText;
            }
          } else {
            // console.log("DEBUG: No Objectron result this frame."); // Reduce spam
            objectronBoundingBox.visible = false;
            if (!infoDivElement.textContent.startsWith('AR Session Running')) {
              infoDivElement.textContent =
                'AR Session Running. Point at a Shoe.';
            }
          }
          renderer.render(scene, camera);
        } catch (error) {
          console.error(
            '!!!!!!!!!!!!!!!! ERROR INSIDE onXRFrame !!!!!!!!!!!!!!!!'
          );
          console.error(error);
          console.error('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
          if (currentSession) {
            console.log('Ending session due to frame error...');
            currentSession
              .end()
              .catch((endErr) =>
                console.error('Error ending session post-error:', endErr)
              );
          }
          return; // OK Return
        }
      } // End of onXRFrame

      // --- Start the application ---
      document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM Ready.');
        init();
      });
      console.log('--- JS module execution finished (Objectron Corrected) ---');
    </script>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>
      eruda.init();
    </script>
  </body>
</html>
