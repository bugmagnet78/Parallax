<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>WebXR Measurement - Three.js (Local Hint Test)</title>
    <style>
      /* CSS styles */
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: #000;
        color: white;
      }
      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display: block;
        color: white;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        font-size: 16px;
        box-sizing: border-box;
      }
      #start-ar-button {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        padding: 14px 28px;
        font-size: 18px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        z-index: 101;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        transition: background-color 0.3s ease;
      }
      #start-ar-button:disabled {
        background-color: #555;
        color: #aaa;
        cursor: not-allowed;
        box-shadow: none;
      }
      #start-ar-button:hover:not(:disabled) {
        background-color: #0056b3;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="info">Initializing...</div>
    <button id="start-ar-button" disabled>Start Measurement</button>
    <canvas id="webgl-canvas"></canvas>

    <script type="module">
      console.log(
        '--- JavaScript module execution started (Local Hint Test) ---'
      );

      import * as THREE from 'three';

      console.log(
        'Three.js module imported successfully:',
        THREE ? 'Yes' : 'No'
      );

      // --- Relevant Context ---
      // Current time: Friday, March 28, 2025 at 10:05 PM
      // Location: Kochi, Kerala, India

      // Global variables
      let camera, scene, renderer;
      let hitTestSource = null;
      let hitTestSourceRequested = false;
      let currentSession = null;
      let referenceSpace = null;
      let latestHitPoseMatrix = null;
      let selectEventPending = false;
      let placedMarkers = [];

      const infoDivElement = document.getElementById('info');
      const startButtonElement = document.getElementById('start-ar-button');
      const canvasElement = document.getElementById('webgl-canvas');

      // --- Function Definitions (Defined ONCE) ---

      // --- UPDATED init(): Remove antialias ---
      function init() {
        console.log('init() called');
        if (!infoDivElement || !startButtonElement || !canvasElement) {
          console.error('FATAL: UI/Canvas element missing.');
          alert('UI Error.');
          return;
        }
        infoDivElement.textContent = 'Setting up Scene & Renderer...';
        try {
          scene = new THREE.Scene();
          camera = new THREE.PerspectiveCamera(
            70,
            window.innerWidth / window.innerHeight,
            0.01,
            40
          );
          // *** CHANGE: Removed antialias: true ***
          renderer = new THREE.WebGLRenderer({
            canvas: canvasElement,
            alpha: true,
          });
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.xr.enabled = true; // Enable WebXR AFTER renderer setup
          console.log(
            'Three.js Renderer initialized (No Antialias), XR enabled.'
          ); // Updated log
          const light = new THREE.AmbientLight(0xffffff, 1.0);
          scene.add(light);
          const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
          dirLight.position.set(1, 1, 1);
          scene.add(dirLight);
        } catch (error) {
          console.error('Error during Three.js setup:', error);
          infoDivElement.textContent = '3D Setup Error: ' + error.message;
          displayCompatibilityError('Three.js setup failed.');
          return;
        }
        infoDivElement.textContent = 'Checking WebXR support...';
        checkXRSupport();
        window.addEventListener('resize', onWindowResize, false);
      }

      async function checkXRSupport() {
        /* ... unchanged ... */
      }
      function displayCompatibilityError(message) {
        /* ... unchanged ... */
      }
      async function startARSession() {
        /* ... unchanged ... */
      }

      // --- UPDATED onSessionStarted: Change hint to 'local' ---
      async function onSessionStarted(session) {
        infoDivElement.textContent =
          'AR Session Active. Configuring Renderer & Spaces...';
        console.log('onSessionStarted called.');
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);
        console.log("'select' event listener added.");

        // --- ** CHANGE: Configure Three.js Reference Space Type hint to 'local' ** ---
        try {
          console.log(
            "Setting Three.js reference space type hint to 'local'..."
          ); // Changed hint
          renderer.xr.setReferenceSpaceType('local'); // *** TRY 'local' ***
          console.log("Reference space type hint set to 'local'."); // Changed log
        } catch (err) {
          console.error('Error setting reference space type hint:', err);
          infoDivElement.textContent =
            'Error configuring reference space hint.';
          try {
            await session.end();
          } catch (e) {}
          return;
        }
        // --- End Configuration Change ---

        // --- CRITICAL STEP: Link session to Three.js Renderer ---
        console.log('Attempting: await renderer.xr.setSession(session)...');
        try {
          await renderer.xr.setSession(session); // Will now use the 'local' hint
          console.log('Successfully set renderer XR session.');
        } catch (err) {
          console.error('Error calling renderer.xr.setSession:', err);
          console.log('Session object at error:', session);
          console.log('renderer.xr object at error:', renderer.xr);
          if (err.message.includes('reference space type')) {
            infoDivElement.textContent = `Fatal: Could not get required ref space ('local' hint) via Three.js: ${err.message}`;
          } // Updated msg
          else {
            infoDivElement.textContent =
              'Fatal: Could not link session to renderer: ' + err.message;
          }
          try {
            await session.end();
          } catch (e) {}
          return;
        }

        // --- Get the reference space Three.js established ---
        referenceSpace = renderer.xr.getReferenceSpace();
        if (!referenceSpace) {
          console.error(
            'Failed to get reference space from Three.js Manager after setSession.'
          );
          infoDivElement.textContent =
            'Fatal: Failed coordinate system setup via Three.js.';
          try {
            await session.end();
          } catch (e) {}
          return;
        }
        let referenceSpaceType = 'unknown (from Three.js)';
        console.log(
          `Successfully using reference space from Three.js (requested 'local').`
        ); // Updated log
        infoDivElement.textContent = `Using main space. Setting up hit test...`;

        // --- Request Hit Test Source (Logic Unchanged) ---
        hitTestSource = null;
        hitTestSourceRequested = false;
        try {
          console.log("Attempting 'viewer' space for hit test setup");
          const viewerSpace = await session.requestReferenceSpace('viewer');
          console.log("Got 'viewer' space for hit test setup.");
          console.log('Attempting hit test source...');
          hitTestSource = await session.requestHitTestSource({
            space: viewerSpace,
          });
          hitTestSourceRequested = true;
          console.log('Hit test source obtained successfully.');
          infoDivElement.textContent =
            'AR Ready. Point at surface & tap to place marker.';
        } catch (err) {
          console.error(`Error during hit test setup: ${err.message}`);
          infoDivElement.textContent = `Main space OK, but Hit-Test setup failed: ${err.message}`;
          hitTestSourceRequested = false;
          console.warn('Proceeding without hit testing.');
        }

        // --- Start Render Loop (Logic Unchanged) ---
        if (referenceSpace) {
          renderer.setAnimationLoop(onXRFrame);
          console.log('Three.js Render Loop started.');
        } else {
          console.error(
            'Cannot start render loop without referenceSpace from Three.js.'
          );
        }
      }
      // --- END UPDATED onSessionStarted ---

      function onSessionEnded(/*event*/) {
        /* ... unchanged ... */
      }
      function onWindowResize() {
        /* ... unchanged ... */
      }
      function onSelect(event) {
        /* ... unchanged ... */
      }
      function onXRFrame(timestamp, frame) {
        /* ... unchanged ... */
      }
      function placeMarker(matrixArray) {
        /* ... unchanged ... */
      }

      // --- Start the application ---
      document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM Ready.');
        init();
      });
      console.log('--- JS module execution finished (Local Hint Test) ---');

      // --- Unchanged Function Bodies (ensure they exist only once) ---
      async function checkXRSupport() {
        console.log('checkXRSupport() called.');
        infoDivElement.textContent = 'Checking WebXR capabilities...';
        console.log('navigator.xr:', navigator.xr);
        if ('xr' in navigator && navigator.xr) {
          console.log('navigator.xr exists...');
          infoDivElement.textContent = 'Checking immersive-ar...';
          try {
            const basicSupport = await navigator.xr.isSessionSupported(
              'immersive-ar'
            );
            console.log(`Basic 'immersive-ar' supported: ${basicSupport}`);
            if (basicSupport) {
              infoDivElement.textContent = 'Checking hit-test...';
              console.log('Checking immersive-ar WITH hit-test...');
              const featureSupport = await navigator.xr.isSessionSupported(
                'immersive-ar',
                { requiredFeatures: ['hit-test'] }
              );
              console.log(
                `'immersive-ar' with 'hit-test' supported: ${featureSupport}`
              );
              if (featureSupport) {
                infoDivElement.textContent = 'Ready! Click "Start Measurement"';
                startButtonElement.disabled = false;
                startButtonElement.addEventListener('click', startARSession);
                console.log('AR Button enabled.');
              } else {
                infoDivElement.textContent =
                  'AR supported, but Hit Test required.';
                console.error('Hit-test feature not supported.');
                displayCompatibilityError('Hit-test feature not supported.');
              }
            } else {
              infoDivElement.textContent = 'Immersive AR not supported.';
              console.error('Basic immersive-ar not supported.');
              displayCompatibilityError('Immersive AR mode not supported.');
            }
          } catch (err) {
            infoDivElement.textContent =
              'WebXR support check Error: ' + err.message;
            console.error('Error isSessionSupported:', err);
            displayCompatibilityError(err.message);
          }
        } else {
          infoDivElement.textContent = 'WebXR API not found.';
          console.error('navigator.xr object not found.');
          displayCompatibilityError('WebXR API not available.');
        }
      }
      function displayCompatibilityError(message) {
        console.error('Compatibility Error:', message);
        startButtonElement.disabled = true;
      }
      async function startARSession() {
        infoDivElement.textContent = 'Starting AR session...';
        startButtonElement.disabled = true;
        startButtonElement.style.display = 'none';
        console.log('Attempting startARSession...');
        if (currentSession) {
          console.warn('Session active? Ending.');
          try {
            await currentSession.end();
          } catch (e) {}
          currentSession = null;
        }
        try {
          currentSession = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['hit-test'],
          });
          console.log('requestSession succeeded.');
          onSessionStarted(currentSession);
        } catch (error) {
          console.error('Failed startARSession:', error);
          infoDivElement.textContent = `Failed AR Start: ${error.message}`;
          startButtonElement.style.display = 'block';
          startButtonElement.disabled = false;
        }
      }
      function onSessionEnded(/*event*/) {
        console.log('onSessionEnded called.');
        currentSession?.removeEventListener('select', onSelect);
        currentSession = null;
        hitTestSourceRequested = false;
        hitTestSource = null;
        referenceSpace = null;
        placedMarkers.forEach((marker) => {
          scene.remove(marker);
        });
        placedMarkers = [];
        try {
          renderer.setAnimationLoop(null);
          console.log('Three.js Render Loop stopped.');
        } catch (error) {
          console.error('Error stopping loop:', error);
        }
        infoDivElement.textContent = 'AR Session ended. Click Start again.';
        startButtonElement.style.display = 'block';
        startButtonElement.disabled = false;
        console.log('AR Session Ended.');
      }
      function onWindowResize() {
        if (!renderer.xr.isPresenting) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }
      function onSelect(event) {
        console.log('Select event detected.');
        selectEventPending = true;
      }
      function onXRFrame(timestamp, frame) {
        if (!frame) {
          return;
        }
        latestHitPoseMatrix = null;
        if (hitTestSourceRequested && hitTestSource && referenceSpace) {
          try {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const hitPose = hit.getPose(referenceSpace);
              if (hitPose) {
                latestHitPoseMatrix = hitPose.transform.matrix;
              }
            }
          } catch (error) {
            /* Ignore */
          }
        }
        if (selectEventPending) {
          console.log('Processing select...');
          if (latestHitPoseMatrix) {
            console.log('Placing marker...');
            placeMarker(latestHitPoseMatrix);
          } else {
            infoDivElement.textContent = 'Tap processed, no surface hit.';
            console.log('No hit pose on tap.');
          }
          selectEventPending = false;
        }
        try {
          renderer.render(scene, camera);
        } catch (error) {
          console.error('Render error:', error);
        }
      }
      function placeMarker(matrixArray) {
        const geometry = new THREE.SphereGeometry(0.02, 16, 16);
        const material = new THREE.MeshStandardMaterial({
          color: 0xff0000,
          roughness: 0.4,
          metalness: 0.1,
        });
        const marker = new THREE.Mesh(geometry, material);
        marker.matrix.fromArray(matrixArray);
        marker.matrix.decompose(
          marker.position,
          marker.quaternion,
          marker.scale
        );
        marker.scale.set(1, 1, 1);
        scene.add(marker);
        placedMarkers.push(marker);
        console.log(
          `Placed marker #${placedMarkers.length}:`,
          marker.position.x.toFixed(3),
          marker.position.y.toFixed(3),
          marker.position.z.toFixed(3)
        );
        if (placedMarkers.length === 1) {
          infoDivElement.textContent = 'First marker placed. Tap again.';
        } else if (placedMarkers.length >= 2) {
          infoDivElement.textContent = `${placedMarkers.length} markers placed.`;
        }
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>
      eruda.init();
    </script>
  </body>
</html>
