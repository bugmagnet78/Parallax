<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>WebXR + MediaPipe Objectron Test</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: #000;
        color: white;
      }
      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display: block;
        color: white;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        font-size: 16px;
        box-sizing: border-box;
        min-height: 3em;
      }
      .button-container {
        position: absolute;
        bottom: 30px;
        width: 100%;
        text-align: center;
        z-index: 101;
      }
      .button-container button {
        padding: 12px 24px;
        font-size: 16px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        transition: background-color 0.3s ease;
      }
      .button-container button:disabled {
        background-color: #555;
        color: #aaa;
        cursor: not-allowed;
        box-shadow: none;
      }
      .button-container button:hover:not(:disabled) {
        background-color: #0056b3;
      }
      canvas#webgl-canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }
      video#input-video {
        display: none;
      } /* Hide the video element used for input */
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
        }
      }
    </script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/objectron/objectron.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="info">Initializing...</div>
    <div class="button-container">
      <button id="start-ar-button" disabled>Start AR Objectron</button>
    </div>
    <video id="input-video"></video> <canvas id="webgl-canvas"></canvas>
    <script type="module">
      console.log(
        '--- JavaScript module execution started (Objectron Test) ---'
      );

      import * as THREE from 'three';

      console.log('Three.js imported:', THREE ? 'Yes' : 'No');
      console.log(
        'MediaPipe Objectron available:',
        window.Objectron ? 'Yes' : 'No'
      );

      // --- Relevant Context ---
      // Current time: Sunday, March 30, 2025 at 3:35 PM
      // Location: Kochi, Kerala, India

      // Global variables
      let camera, scene, renderer; // Three.js
      let currentSession = null; // WebXR
      let referenceSpace = null;
      let objectron = null; // MediaPipe
      let cameraHelper = null; // MediaPipe Camera Util
      let latestObjectronResult = null; // Store detection result
      let objectronBoundingBox = null; // Three.js Box Helper

      const infoDivElement = document.getElementById('info');
      const startButtonElement = document.getElementById('start-ar-button');
      const videoElement = document.getElementById('input-video');
      const canvasElement = document.getElementById('webgl-canvas'); // Three.js output canvas

      // --- Initialization ---
      async function init() {
        console.log('init() called');
        if (
          !infoDivElement ||
          !startButtonElement ||
          !canvasElement ||
          !videoElement ||
          !window.Objectron
        ) {
          console.error(
            'FATAL: UI/Canvas/Video/Objectron element missing or MP not loaded.'
          );
          infoDivElement.textContent =
            'Error: Required elements or MediaPipe Objectron not loaded.';
          startButtonElement.disabled = true;
          return;
        }

        infoDivElement.textContent = 'Setting up Scene & Renderer...';
        // --- Three.js Setup ---
        try {
          scene = new THREE.Scene();
          camera = new THREE.PerspectiveCamera(
            70,
            window.innerWidth / window.innerHeight,
            0.01,
            40
          );
          renderer = new THREE.WebGLRenderer({
            canvas: canvasElement,
            antialias: true,
            alpha: true,
          }); // Keep AA for visual quality if possible
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.xr.enabled = true;
          console.log('Three.js Renderer initialized, XR enabled.');
          const light = new THREE.AmbientLight(0xffffff, 1.0);
          scene.add(light);
          const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
          dirLight.position.set(1, 1, 1);
          scene.add(dirLight);

          // --- Setup Objectron Box Visualizer ---
          // Create an empty Box3 and a helper to visualize it
          const initialBox = new THREE.Box3(
            new THREE.Vector3(-0.1, -0.1, -0.1),
            new THREE.Vector3(0.1, 0.1, 0.1)
          ); // Placeholder size
          objectronBoundingBox = new THREE.Box3Helper(initialBox, 0xffff00); // Yellow box
          objectronBoundingBox.visible = false; // Initially hidden
          scene.add(objectronBoundingBox);
          console.log('Objectron bounding box helper created.');
        } catch (error) {
          console.error('Init Error:', error);
          displayCompatibilityError('3D Setup failed.');
          return;
        }

        // --- MediaPipe Objectron Setup ---
        infoDivElement.textContent = 'Loading Objectron Model...';
        try {
          objectron = new Objectron({
            locateFile: (file) => {
              // Point to the CDN location of WASM files and models
              // Note: Models need to be hosted or use CDN links if available
              // Using generic vision WASM link - check MediaPipe docs for Objectron specifics
              // Model files (e.g., shoe.tflite) also need to be accessible.
              console.log(`Locating file: ${file}`);
              // Using newer vision task WASM location - may need adjustment for legacy Objectron
              return `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm/${file}`;
              // Older path might be: `https://cdn.jsdelivr.net/npm/@mediapipe/objectron@0.4/${file}`
            },
          });
          console.log('Objectron instance created.');

          objectron.setOptions({
            staticImageMode: false,
            // --- CHOOSE MODEL ---
            modelName: 'Shoe', // Or 'Chair', 'Cup', 'Camera'
            //--------------------
            maxNumObjects: 1, // Detect only one object for simplicity
            minDetectionConfidence: 0.5, // Confidence threshold
            minTrackingConfidence: 0.7, // Tracking threshold
          });
          console.log('Objectron options set (Model: Shoe).');

          objectron.onResults(onObjectronResults); // Set the callback
          console.log('Objectron results callback set.');
        } catch (error) {
          console.error('MediaPipe Init Error:', error);
          displayCompatibilityError('MediaPipe setup failed.');
          return;
        }

        // --- Camera Setup using MediaPipe Utils ---
        infoDivElement.textContent = 'Setting up Camera...';
        try {
          // Use Camera util to link video element and start feeding frames
          cameraHelper = new Camera(videoElement, {
            onFrame: async () => {
              // Send the video frame to Objectron for processing
              await objectron.send({ image: videoElement });
            },
            width: 640, // Lower resolution for performance
            height: 480,
          });
          await cameraHelper.start(); // Start the camera feed and processing loop
          console.log('MediaPipe Camera util started.');
          infoDivElement.textContent = 'Camera OK. Checking WebXR...';
        } catch (error) {
          console.error('Camera Setup Error:', error);
          displayCompatibilityError('Camera setup failed.');
          return;
        }

        // --- Check WebXR Support ---
        checkXRSupport();
        window.addEventListener('resize', onWindowResize, false);
      }

      // --- MediaPipe Objectron Results Callback ---
      function onObjectronResults(results) {
        // This function is called by MediaPipe when it has detection results
        if (results.objectDetections && results.objectDetections.length > 0) {
          // Store the result of the first detected object
          latestObjectronResult = results.objectDetections[0];
          // console.log("Objectron detected:", latestObjectronResult); // DEBUG - Can be very spammy
        } else {
          latestObjectronResult = null; // No object detected
        }
      }

      // --- WebXR Support Check ---
      async function checkXRSupport() {
        // (Checks 'immersive-ar', enables button if supported)
        console.log('checkXRSupport() called.');
        console.log('navigator.xr:', navigator.xr);
        if ('xr' in navigator && navigator.xr) {
          console.log('navigator.xr exists...');
          infoDivElement.textContent = 'Checking immersive-ar...';
          try {
            const supported = await navigator.xr.isSessionSupported(
              'immersive-ar'
            );
            console.log(`'immersive-ar' supported: ${supported}`);
            if (supported) {
              infoDivElement.textContent = 'Ready! Click "Start AR Objectron"';
              startButtonElement.disabled = false;
              startButtonElement.addEventListener(
                'click',
                handleStartButtonClick
              );
              console.log('AR Button enabled.');
            } else {
              infoDivElement.textContent = 'Immersive AR not supported.';
              displayCompatibilityError('Immersive AR not supported.');
            }
          } catch (err) {
            infoDivElement.textContent =
              'WebXR support check Error: ' + err.message;
            console.error('Error isSessionSupported:', err);
            displayCompatibilityError(err.message);
          }
        } else {
          infoDivElement.textContent = 'WebXR API not found.';
          displayCompatibilityError('WebXR API not available.');
        }
      }

      function displayCompatibilityError(message) {
        console.error('Compatibility Error:', message);
        startButtonElement.disabled = true;
        infoDivElement.textContent = message;
      }

      function handleStartButtonClick() {
        if (!currentSession) {
          startARSession();
        }
      }

      // --- WebXR Session Management ---
      async function startARSession() {
        infoDivElement.textContent = 'Starting AR session...';
        startButtonElement.disabled = true;
        startButtonElement.style.display = 'none';
        console.log('Attempting startARSession...');
        if (currentSession) {
          console.warn('Session active? Ending.');
          try {
            await currentSession.end();
          } catch (e) {}
          currentSession = null;
        }
        try {
          // Request session *without* hit-test initially, as Objectron provides the box
          currentSession = await navigator.xr.requestSession(
            'immersive-ar' /*, { requiredFeatures: ['hit-test'] }*/
          );
          console.log('requestSession succeeded.');
          onSessionStarted(currentSession);
        } catch (error) {
          console.error('Failed startARSession:', error);
          infoDivElement.textContent = `Failed AR Start: ${error.message}`;
          startButtonElement.style.display = 'block';
          startButtonElement.disabled = false;
        }
      }

      async function onSessionStarted(session) {
        console.log('onSessionStarted called.');
        session.addEventListener('end', onSessionEnded);
        // No 'select' listener needed for automatic detection

        // Configure and link renderer
        try {
          console.log("Setting hint 'local'...");
          renderer.xr.setReferenceSpaceType('local');
          console.log('Hint set.');
          console.log('Attempting setSession...');
          await renderer.xr.setSession(session);
          console.log('Successfully set renderer XR session.');
        } catch (err) {
          console.error('Error setSession:', err);
          infoDivElement.textContent = 'Fatal: Link renderer error.';
          try {
            await session.end();
          } catch (e) {}
          return;
        }

        // Get reference space established by Three.js
        referenceSpace = renderer.xr.getReferenceSpace();
        if (!referenceSpace) {
          console.error('Failed get ref space from Manager.');
          infoDivElement.textContent = 'Fatal: No coordinate system.';
          try {
            await session.end();
          } catch (e) {}
          return;
        }
        console.log(`Using reference space from Three.js (requested 'local').`);
        infoDivElement.textContent = 'AR Session Running. Point at a Shoe.';

        // Start Render Loop
        renderer.setAnimationLoop(onXRFrame);
        console.log('Three.js Render Loop started.');
      }

      function onSessionEnded(/*event*/) {
        console.log('onSessionEnded called.');
        currentSession = null;
        referenceSpace = null;
        latestObjectronResult = null;
        try {
          renderer.setAnimationLoop(null);
          console.log('Three.js Render Loop stopped.');
        } catch (error) {
          console.error('Error stopping loop:', error);
        }
        // Stop camera helper? MediaPipe Camera util might need explicit stop
        // cameraHelper?.stop(); // Requires cameraHelper to be accessible or managed differently
        // console.log("Camera helper stopped.");

        // Hide the bounding box
        if (objectronBoundingBox) objectronBoundingBox.visible = false;

        infoDivElement.textContent = 'AR Session ended. Click Start again.';
        startButtonElement.style.display = 'inline-block';
        startButtonElement.disabled = false;
        console.log('AR Session Ended.');
      }

      function onWindowResize() {
        if (!renderer.xr.isPresenting) {
          /* ... resize logic ... */
        }
      } // Unchanged basic resize

      // --- onXRFrame - Render Loop ---
      // --- onXRFrame - Render Loop (with added detection logs) ---
      function onXRFrame(timestamp, frame) {
        if (!frame || !currentSession) {
          return;
        }

        try {
          // Get viewer pose
          const pose = frame.getViewerPose(referenceSpace);
          if (!pose) {
            // console.warn("No viewer pose available this frame."); // Can be spammy
            // Still attempt to render, but skip object placement logic
            renderer.render(scene, camera);
            return;
          }
          const viewMatrix = pose.transform.inverse.matrix; // Needed for transforms? Check Objectron output space
          const cameraWorldMatrix = new THREE.Matrix4().fromArray(
            pose.transform.matrix
          );

          // Check for latest Objectron result
          if (latestObjectronResult) {
            // --- OBJECT DETECTED ---
            console.log('DEBUG: Objectron Result DETECTED this frame.'); // Added Log

            // --- Coordinate Transformation ---
            const objectron_R = latestObjectronResult.rotation; // 3x3 or 4x4 Rotation matrix? (Assume 3x3 Col Major needs composing)
            const objectron_T = latestObjectronResult.translation; // Translation vector [x, y, z]
            const objectron_S = latestObjectronResult.scale; // Scale vector [sx, sy, sz]

            const objectMatrixCamera = new THREE.Matrix4();
            // Example: Constructing 4x4 from 3x3 Rot + Trans (COLUMN MAJOR from MediaPipe to ROW MAJOR for Three)
            // This part is highly dependent on exact format from MP and needs verification/debugging
            objectMatrixCamera.set(
              objectron_R[0],
              objectron_R[3],
              objectron_R[6],
              objectron_T[0],
              objectron_R[1],
              objectron_R[4],
              objectron_R[7],
              objectron_T[1],
              objectron_R[2],
              objectron_R[5],
              objectron_R[8],
              objectron_T[2],
              0,
              0,
              0,
              1
            );
            // Alternative if MP gives Row Major 4x4 already: objectMatrixCamera.fromArray(latestObjectronResult.poseMatrix);

            const objectWorldMatrix = new THREE.Matrix4();
            objectWorldMatrix.multiplyMatrices(
              cameraWorldMatrix,
              objectMatrixCamera
            );

            // --- Update Visualizer ---
            // Update Box3Helper based on matrix (more direct than transforming a Box3)
            objectronBoundingBox.matrix.copy(objectWorldMatrix); // Apply world matrix directly
            // Apply scale - Box3Helper is unit size 1x1x1 centered at origin by default
            objectronBoundingBox.scale.set(
              objectron_S[0],
              objectron_S[1],
              objectron_S[2]
            );
            objectronBoundingBox.matrixAutoUpdate = false; // We are setting matrix directly
            objectronBoundingBox.updateMatrixWorld(true); // Force update if needed

            objectronBoundingBox.visible = true;

            // --- Display Scale ---
            const scaleText = `Est. Scale: X:${objectron_S[0].toFixed(
              3
            )}, Y:${objectron_S[1].toFixed(3)}, Z:${objectron_S[2].toFixed(3)}`;
            if (infoDivElement.textContent !== scaleText) {
              infoDivElement.textContent = scaleText;
            }
          } else {
            // --- NO OBJECT DETECTED ---
            console.log('DEBUG: No Objectron result this frame.'); // Added Log

            objectronBoundingBox.visible = false;
            if (!infoDivElement.textContent.startsWith('AR Session Running')) {
              infoDivElement.textContent =
                'AR Session Running. Point at a Shoe.'; // Reset text
            }
          }

          // Render the main Three.js scene
          renderer.render(scene, camera);
        } catch (error) {
          console.error('Error in onXRFrame:', error);
        }
      }

      // --- Full Code ---
      // Replace the existing onXRFrame function in the previous full code block
      // with this updated version.
      if (!frame || !currentSession) {
        return;
      }

      try {
        // Get viewer pose (needed for coordinate transforms)
        const pose = frame.getViewerPose(referenceSpace);
        if (!pose) {
          console.warn('No viewer pose available this frame.');
          return; // Cannot place object without knowing where camera is
        }
        // View matrix is inverse of camera world matrix
        const viewMatrix = pose.transform.inverse.matrix;
        // Camera world position can be extracted if needed
        // const cameraWorldPosition = new THREE.Vector3().setFromMatrixPosition(pose.transform.matrix);

        // Check for latest Objectron result
        if (latestObjectronResult) {
          // --- Coordinate Transformation ---
          // Objectron provides pose relative to camera. We need world pose.
          // Get Objectron's pose matrix (Rotation + Translation)
          // Note: MediaPipe uses column-major matrices, Three.js uses row-major (usually).
          // Need to be careful with matrix multiplication order and potential transposition.
          // Assuming Objectron provides R and T separately:
          const objectron_R = latestObjectronResult.rotation; // 3x3 or 4x4 Rotation matrix (Column-major?)
          const objectron_T = latestObjectronResult.translation; // Translation vector [x, y, z]
          const objectron_S = latestObjectronResult.scale; // Scale vector [sx, sy, sz]

          // Construct object's pose matrix relative to the camera
          const objectMatrixCamera = new THREE.Matrix4();
          // Assuming objectron_R is 3x3 column-major. Need to convert to 4x4 row-major for Three.js
          // This conversion/multiplication is complex and error-prone!
          // Placeholder - this needs careful implementation based on exact MP output format:
          objectMatrixCamera.set(
            // Example assuming COLUMN-MAJOR R input needing transpose + T
            objectron_R[0],
            objectron_R[3],
            objectron_R[6],
            objectron_T[0],
            objectron_R[1],
            objectron_R[4],
            objectron_R[7],
            objectron_T[1],
            objectron_R[2],
            objectron_R[5],
            objectron_R[8],
            objectron_T[2],
            0,
            0,
            0,
            1
          );
          // If R is already 4x4 row-major, just use .fromArray(objectron_R) and .setPosition(objectron_T)

          // Get camera's world matrix (inverse of view matrix)
          const cameraWorldMatrix = new THREE.Matrix4().fromArray(
            pose.transform.matrix
          );

          // Calculate object's world matrix: World = CameraWorld * ObjectLocalCamera
          const objectWorldMatrix = new THREE.Matrix4();
          objectWorldMatrix.multiplyMatrices(
            cameraWorldMatrix,
            objectMatrixCamera
          );

          // --- Update Visualizer ---
          // Update the Box3Helper based on the calculated world pose and scale
          // Box3Helper needs a Box3. Create one representing the scaled unit cube at origin.
          const unitBox = new THREE.Box3(
            new THREE.Vector3(-0.5, -0.5, -0.5),
            new THREE.Vector3(0.5, 0.5, 0.5)
          );
          // Apply scale first
          unitBox.min.multiplyScalar(2); // Match helper size if needed? Check Box3Helper source maybe. Or just apply scale to helper?
          unitBox.max.multiplyScalar(2);
          // unitBox.min.multiply(new THREE.Vector3(objectron_S[0], objectron_S[1], objectron_S[2]));
          // unitBox.max.multiply(new THREE.Vector3(objectron_S[0], objectron_S[1], objectron_S[2]));

          // Apply world transformation to the unit box
          unitBox.applyMatrix4(objectWorldMatrix); // This transforms the box corners

          // Update the Box3Helper to match the transformed box
          objectronBoundingBox.box.copy(unitBox); // Update the helper's internal box
          // Apply Scale directly to helper might be simpler? Needs testing.
          // objectronBoundingBox.position.setFromMatrixPosition(objectWorldMatrix);
          // objectronBoundingBox.quaternion.setFromRotationMatrix(objectWorldMatrix);
          // objectronBoundingBox.scale.set(objectron_S[0]*2, objectron_S[1]*2, objectron_S[2]*2); // Multiply by 2 because Box3Helper draws a box of size 2?

          objectronBoundingBox.visible = true;

          // --- Display Scale ---
          // IMPORTANT: Verify what these scale values represent! Meters? Relative?
          const scaleText = `Est. Scale: X:${objectron_S[0].toFixed(
            3
          )}, Y:${objectron_S[1].toFixed(3)}, Z:${objectron_S[2].toFixed(3)}`;
          if (infoDivElement.textContent !== scaleText) {
            // Avoid constant updates
            infoDivElement.textContent = scaleText;
            // console.log(scaleText); // Optional console log
          }
        } else {
          // No object detected this frame
          objectronBoundingBox.visible = false;
          if (!infoDivElement.textContent.startsWith('AR Session Running')) {
            // Avoid flicker
            infoDivElement.textContent = 'AR Session Running. Point at a Shoe.';
          }
        }

        // Render the main Three.js scene
        renderer.render(scene, camera);
      } catch (error) {
        console.error('Error in onXRFrame:', error);
        // Consider stopping the loop or session on error
      }

      // --- Start the application ---
      document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM Ready.');
        init();
      });
      console.log('--- JS module execution finished (Objectron Test) ---');
    </script>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>
      eruda.init();
    </script>
  </body>
</html>
